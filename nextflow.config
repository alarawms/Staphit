// nextflow.config

params {
    outdir = './results'
    input = 'samplesheet.csv'
    reads_limit = 1000000 // Default limit (approx 100x coverage for S. aureus). Use --reads_limit N to adjust or null to disable.
    max_downloads = null // Limit the number of SRA samples to download/process. Set to an integer to enable.
    species = null // Species to search for in SRA (e.g., "Staphylococcus aureus"). If set, overrides input samplesheet.
    search_limit = 6 // Number of samples to fetch when searching
    
    // Resource Max Limits
    max_memory = '14.GB'
    max_cpus = 12
    max_time = '24.h'
}

process {
    // Default resources
    cpus = { check_max( 1 * task.attempt, 'cpus' ) }
    memory = { check_max( 2.GB * task.attempt, 'memory' ) }
    time = { check_max( 2.h * task.attempt, 'time' ) }

    errorStrategy = { task.exitStatus in [143,137,104,134,139,250] ? 'retry' : 'finish' }
    maxRetries = 3

    withName: 'FETCH_SRA' {
        container = 'quay.io/biocontainers/sra-tools:3.0.0--pl5321hd0d85c6_1'
        errorStrategy = 'retry' 
        maxRetries = 3
        // SRA tools can be flaky, give them a bit more time/mem on retry
        cpus = 1
        memory = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'TRIMMOMATIC' {
        container = 'quay.io/biocontainers/trimmomatic:0.39--hdfd78af_2'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'FASTQC' {
        container = 'quay.io/biocontainers/fastqc:0.11.9--hdfd78af_1'
        cpus = { check_max( 1 * task.attempt, 'cpus' ) }
        memory = { check_max( 2.GB * task.attempt, 'memory' ) }
    }
    withName: 'SPADES' {
        container = 'quay.io/biocontainers/spades:3.15.5--h95f258a_1'
        cpus = { check_max( 4 * task.attempt, 'cpus' ) }
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
    }
    withName: 'PROKKA' {
        container = 'quay.io/biocontainers/prokka:1.14.6--pl5321hdfd78af_5'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'ABRICATE' {
        container = 'quay.io/biocontainers/abricate:1.0.1--ha8f3691_1'
        cpus = 1
        memory = { check_max( 2.GB * task.attempt, 'memory' ) }
    }
    withName: 'MLST' {
        container = 'staphb/mlst:latest'
        cpus = 1
        memory = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'QUAST' {
        container = 'staphb/quast:latest'
        cpus = { check_max( 1 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'PANAROO' {
        container = 'quay.io/biocontainers/panaroo:1.3.2--pyhdfd78af_0'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 6.GB * task.attempt, 'memory' ) }
    }
    withName: 'IQTREE' {
        container = 'staphb/iqtree:latest'
        cpus = { check_max( 4 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'SNP_DISTS' {
        container = 'staphb/snp-dists:latest'
        cpus = 1
        memory = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'MULTIQC' {
        container = 'quay.io/biocontainers/multiqc:1.14--pyhdfd78af_0'
        cpus = 1
        memory = { check_max( 2.GB * task.attempt, 'memory' ) }
    }
    withName: 'MASH' {
        container = 'staphb/mash:latest'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'AMRFINDERPLUS' {
        container = 'staphb/ncbi-amrfinderplus:latest'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'SPATYPER' {
        container = 'quay.io/biocontainers/spatyper:0.3.3--py_0'
        cpus = 1
        memory = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'SCCMEC' {
        container = 'alarawms/sccmec_typer:latest'
        containerOptions = '--entrypoint ""'
        cpus = 1
        memory = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'FASTP' {
        container = 'quay.io/biocontainers/fastp:0.23.4--h5f740d0_0'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'AGR_TYPING' {
        container = 'alarawms/staph_agr_typer:latest'
        containerOptions = '--entrypoint ""'
        cpus = 1
        memory = { check_max( 2.GB * task.attempt, 'memory' ) }
    }
    withName: 'FETCH_RESFINDER_DB' {
        container = 'bitnami/git:latest'
        cpus = 1
        memory = '1.GB'
    }
    withName: 'INDEX_DB' {
        container = 'staphb/kma:latest'
        cpus = 2
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'KMA' {
        container = 'staphb/kma:latest'
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'VISUALIZATION' {
        container = 'python:3.9-slim'
        cpus = 1
        memory = { check_max( 2.GB * task.attempt, 'memory' ) }
    }

}

profiles {
    docker {
        docker.enabled = true
    }
    ibex {
        process.executor = 'slurm'
        process.queue = 'batch'
        process.clusterOptions = '--constraint=intel'
        singularity.enabled = true
        singularity.autoMounts = true
        docker.enabled = false
    }
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
